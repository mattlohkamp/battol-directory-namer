import { describe, expect, it } from "vitest";
import {
	dateToSQLDatetimeString,
	isValidSQLDatetimeString,
	SQLDatetimeStringToDate,
	stripEmoji,
} from "./utils";
// Generated by Qodo Gen

describe("stripEmoji", () => {
	// Remove single emoji from middle of string
	it("should remove emoji from middle of text string", () => {
		const input = "Hello ðŸ‘‹ World";
		const expected = "Hello  World";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle empty string input
	it("should return empty string when input is empty", () => {
		const input = "";
		const expected = "";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Remove multiple emojis from string
	it("should remove multiple emojis from a string", () => {
		const input = "Hello ðŸ‘‹ World ðŸŒ!";
		const expected = "Hello  World !";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Remove consecutive emojis from string
	it("should remove consecutive emojis from string", () => {
		const input = "Hello ðŸ‘‹ðŸ‘‹ World";
		const expected = "Hello  World";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Return original string when no emojis present
	it("should return the original string when no emojis are present", () => {
		const input = "Hello World";
		const expected = "Hello World";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle string with only emojis
	it("should return an empty string when input is only emojis", () => {
		const input = "ðŸ‘‹ðŸ˜ŠðŸŽ‰";
		const expected = "";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle string with emoji variants/modifiers
	it("should remove emoji variants and modifiers from the string", () => {
		const input = "Hello ðŸ‘‹ðŸ½ World ðŸŒðŸŒŽðŸŒ";
		const expected = "Hello  World ";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle string with unicode characters but no emojis
	it("should return the same string when there are no emojis", () => {
		const input = "Hello World ã“ã‚“ã«ã¡ã¯";
		const expected = "Hello World ã“ã‚“ã«ã¡ã¯";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle very long strings with many emojis
	it("should remove all emojis from a very long string", () => {
		const input =
			"ðŸ˜€".repeat(1000) +
			"This is a very long string with many emojis" +
			"ðŸ˜€".repeat(1000);
		const expected = "This is a very long string with many emojis";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle strings with surrogate pairs
	it("should remove emoji with surrogate pairs from text", () => {
		const input = "Hello ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ World";
		const expected = "Hello  World";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle strings with emoji + ZWJ sequences
	it("should remove emoji and ZWJ sequences from the string", () => {
		const input = "ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ Family";
		const expected = " Family";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle strings with emoji sequences (e.g. family emojis)
	it("should remove family emoji sequences from text", () => {
		const input = "Family ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦ is important";
		const expected = "Family  is important";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle strings with regional indicators
	it("should remove regional indicator symbols from the string", () => {
		const input = "USðŸ‡ºðŸ‡¸ is different from CAðŸ‡¨ðŸ‡¦";
		const expected = "US is different from CA";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});

	// Handle strings with emoji presentation selectors
	it("should remove emoji presentation selectors from string", () => {
		const input = "Hello\uFE0F World";
		const expected = "Hello World";

		const result = stripEmoji(input);

		expect(result).toBe(expected);
	});
});

// Generated by Qodo Gen

describe("isValidDateString", () => {
	// Valid date string in format YYYY-MM-DD HH:mm:ss returns true
	it("should return true when date string matches YYYY-MM-DD HH:mm:ss format", () => {
		const validDateString = "2023-12-25 15:30:00";
		const result = isValidSQLDatetimeString(validDateString);
		expect(result).toBe(true);
	});

	// Empty string returns false
	it("should return false when string is empty", () => {
		const emptyString = "";
		const result = isValidSQLDatetimeString(emptyString);
		expect(result).toBe(false);
	});

	// Date string with leading zeros for single digit values
	it("should return true when date string has leading zeros for single digit values", () => {
		const dateStringWithLeadingZeros = "2023-01-05 09:07:03";
		const result = isValidSQLDatetimeString(dateStringWithLeadingZeros);
		expect(result).toBe(true);
	});

	// Invalid date format with slashes instead of hyphens
	it("should return false when date string uses slashes instead of hyphens", () => {
		const invalidDateString = "2023/12/25 15:30:00";
		const result = isValidSQLDatetimeString(invalidDateString);
		expect(result).toBe(false);
	});

	// Missing seconds component in time
	it("should return false when date string is missing seconds component", () => {
		const invalidDateString = "2023-12-25 15:30";
		const result = isValidSQLDatetimeString(invalidDateString);
		expect(result).toBe(false);
	});

	// Date string with invalid number of digits
	it("should return false when date string has invalid number of digits (missing leading 0)", () => {
		const invalidDateString = "2023-12-5 15:3:00";
		const result = isValidSQLDatetimeString(invalidDateString);
		expect(result).toBe(false);
	});

	// Missing time component entirely
	it("should return false when date string is missing time component", () => {
		const invalidDateString = "2023-12-25";
		const result = isValidSQLDatetimeString(invalidDateString);
		expect(result).toBe(false);
	});

	// Date string with milliseconds component
	it("should return false when date string includes milliseconds", () => {
		const dateStringWithMilliseconds = "2023-12-25 15:30:00.123";
		const result = isValidSQLDatetimeString(dateStringWithMilliseconds);
		expect(result).toBe(false);
	});
});

// Generated by Qodo Gen

describe("SQLDatetimeStringToDate", () => {
	// Convert valid SQL datetime string in format 'YYYY-MM-DD HH:mm:ss' to JavaScript Date object
	it("should convert valid SQL datetime string to Date object", () => {
		const sqlDateTime = "2025-02-03 14:30:00";
		const result = SQLDatetimeStringToDate(sqlDateTime);
		expect(result.getFullYear()).toBe(2025);
		expect(result.getMonth()).toBe(1); // 0-based month index
		expect(result.getDate()).toBe(3);
		expect(result.getHours()).toBe(14);
		expect(result.getMinutes()).toBe(30);
		expect(result.getSeconds()).toBe(0);
	});

	// Handle invalid SQL datetime string format
	it("should throw error for invalid SQL datetime string format", () => {
		const invalidDateTime = "2025/02/03 14:30:00";
		expect(() => SQLDatetimeStringToDate(invalidDateTime)).toThrow();
	});

	// Handle different time values (morning, afternoon, midnight)
	it("should correctly convert SQL datetime string to Date object for different times of day", () => {
		const morningSqlDateTime = "2025-02-03 08:00:00";
		const afternoonSqlDateTime = "2025-02-03 14:30:00";
		const midnightSqlDateTime = "2025-02-03 00:00:00";

		const morningResult = SQLDatetimeStringToDate(morningSqlDateTime);
		const afternoonResult = SQLDatetimeStringToDate(afternoonSqlDateTime);
		const midnightResult = SQLDatetimeStringToDate(midnightSqlDateTime);

		expect(morningResult).toBeInstanceOf(Date);
		expect(morningResult.getHours()).toBe(8);
		expect(morningResult.getMinutes()).toBe(0);
		expect(morningResult.getSeconds()).toBe(0);

		expect(afternoonResult).toBeInstanceOf(Date);
		expect(afternoonResult.getHours()).toBe(14);
		expect(afternoonResult.getMinutes()).toBe(30);
		expect(afternoonResult.getSeconds()).toBe(0);

		expect(midnightResult).toBeInstanceOf(Date);
		expect(midnightResult.getHours()).toBe(0);
		expect(midnightResult.getMinutes()).toBe(0);
		expect(midnightResult.getSeconds()).toBe(0);
	});

	// Handle different date values (start/middle/end of month)
	it("should correctly convert SQL datetime strings for start, middle, and end of month", () => {
		const startOfMonth = "2025-02-01 00:00:00";
		const middleOfMonth = "2025-02-15 12:00:00";
		const endOfMonth = "2025-02-28 23:59:59";

		const startResult = SQLDatetimeStringToDate(startOfMonth);
		expect(startResult).toBeInstanceOf(Date);
		expect(startResult.getFullYear()).toBe(2025);
		expect(startResult.getMonth()).toBe(1);
		expect(startResult.getDate()).toBe(1);
		expect(startResult.getHours()).toBe(0);
		expect(startResult.getMinutes()).toBe(0);
		expect(startResult.getSeconds()).toBe(0);

		const middleResult = SQLDatetimeStringToDate(middleOfMonth);
		expect(middleResult).toBeInstanceOf(Date);
		expect(middleResult.getFullYear()).toBe(2025);
		expect(middleResult.getMonth()).toBe(1);
		expect(middleResult.getDate()).toBe(15);
		expect(middleResult.getHours()).toBe(12);
		expect(middleResult.getMinutes()).toBe(0);
		expect(middleResult.getSeconds()).toBe(0);

		const endResult = SQLDatetimeStringToDate(endOfMonth);
		expect(endResult).toBeInstanceOf(Date);
		expect(endResult.getFullYear()).toBe(2025);
		expect(endResult.getMonth()).toBe(1);
		expect(endResult.getDate()).toBe(28);
		expect(endResult.getHours()).toBe(23);
		expect(endResult.getMinutes()).toBe(59);
		expect(endResult.getSeconds()).toBe(59);
	});

	// Handle single digit hours/minutes/seconds with leading zeros
	it("should correctly parse datetime with leading zeros in time components", () => {
		const sqlDateTime = "2025-02-03 04:05:06";
		const result = SQLDatetimeStringToDate(sqlDateTime);
		expect(result).toBeInstanceOf(Date);
		expect(result.getFullYear()).toBe(2025);
		expect(result.getMonth()).toBe(1);
		expect(result.getDate()).toBe(3);
		expect(result.getHours()).toBe(4);
		expect(result.getMinutes()).toBe(5);
		expect(result.getSeconds()).toBe(6);
	});

	// Handle empty string input
	it("should throw error when input is an empty string", () => {
		const emptyString = "";
		expect(() => SQLDatetimeStringToDate(emptyString)).toThrow();
	});

	// Convert dates from different years correctly
	it("should convert SQL datetime string from 1999 to Date object", () => {
		const sqlDateTime = "1999-12-31 23:59:59";
		const result = SQLDatetimeStringToDate(sqlDateTime);
		expect(result).toBeInstanceOf(Date);
		expect(result.getFullYear()).toBe(1999);
		expect(result.getMonth()).toBe(11);
		expect(result.getDate()).toBe(31);
		expect(result.getHours()).toBe(23);
		expect(result.getMinutes()).toBe(59);
		expect(result.getSeconds()).toBe(59);
	});

	// throw an error for date string with missing time
	it("should throw an error for SQL datetime string with missing time component", () => {
		const sqlDateTime = "2025-02-03";
		expect(() => SQLDatetimeStringToDate(sqlDateTime)).toThrow();
	});

	// Handle string with extra whitespace
	it("should convert SQL datetime string with extra whitespace to Date object", () => {
		const sqlDateTime = "  2025-02-03 14:30:00  ";
		const result = SQLDatetimeStringToDate(sqlDateTime.trim());
		expect(result).toBeInstanceOf(Date);
		expect(result.getFullYear()).toBe(2025);
		expect(result.getMonth()).toBe(1);
		expect(result.getDate()).toBe(3);
		expect(result.getHours()).toBe(14);
		expect(result.getMinutes()).toBe(30);
		expect(result.getSeconds()).toBe(0);
	});

	// Handle leap year dates correctly
	it("should convert leap year SQL datetime string to Date object", () => {
		const sqlDateTime = "2024-02-29 12:00:00";
		const result = SQLDatetimeStringToDate(sqlDateTime);
		expect(result).toBeInstanceOf(Date);
		expect(result.getFullYear()).toBe(2024);
		expect(result.getMonth()).toBe(1);
		expect(result.getDate()).toBe(29);
		expect(result.getHours()).toBe(12);
		expect(result.getMinutes()).toBe(0);
		expect(result.getSeconds()).toBe(0);
	});

	// Check for Date object validity after conversion
	it("should return a valid Date object when given a correct SQL datetime string", () => {
		const sqlDateTime = "2025-02-03 14:30:00";
		const result = SQLDatetimeStringToDate(sqlDateTime);
		expect(result).toBeInstanceOf(Date);
		expect(result.getFullYear()).toBe(2025);
		expect(result.getMonth()).toBe(1);
		expect(result.getDate()).toBe(3);
		expect(result.getHours()).toBe(14);
		expect(result.getMinutes()).toBe(30);
		expect(result.getSeconds()).toBe(0);
	});
});

// Generated by Qodo Gen

describe("dateToSQLDatetimeString", () => {
	// Convert current date to SQL datetime string in YYYY-MM-DD HH:mm:ss format
	it("should format current date to SQL datetime string", () => {
		const testDate = new Date(2023, 11, 25, 14, 30, 45);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-12-25 14:30:45");
	});

	// Convert date at midnight (00:00:00)
	it("should format date at midnight to SQL datetime string", () => {
		const testDate = new Date(2023, 0, 1, 0, 0, 0);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-01-01 00:00:00");
	});

	// Convert date with single digit month/day/hour/minute/second values
	it("should format date with single digit components to SQL datetime string", () => {
		const testDate = new Date(2023, 0, 5, 4, 3, 2); // January is 0-based
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-01-05 04:03:02");
	});

	// Convert date at last second of day (23:59:59)
	it("should format date at last second of day to SQL datetime string", () => {
		const testDate = new Date(2023, 11, 25, 23, 59, 59);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-12-25 23:59:59");
	});

	// Convert date with double digit month/day/hour/minute/second values
	it("should convert date with double digit values to SQL datetime string", () => {
		const testDate = new Date(2023, 9, 15, 12, 45, 30);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-10-15 12:45:30");
	});

	// Handle month 0 (January) correctly with +1 adjustment
	it("should format date in January to SQL datetime string", () => {
		const testDate = new Date(2023, 0, 15, 10, 5, 30);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-01-15 10:05:30");
	});

	// Handle month 11 (December) correctly with +1 adjustment
	it("should format date in December correctly with +1 month adjustment", () => {
		const testDate = new Date(2023, 11, 15, 10, 5, 30);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("2023-12-15 10:05:30");
	});

	// Handle leap year dates (Feb 29)
	it("should format leap year date to SQL datetime string", () => {
		const leapYearDate = new Date(2020, 1, 29, 12, 0, 0); // February 29, 2020
		const result = dateToSQLDatetimeString(leapYearDate);
		expect(result).toBe("2020-02-29 12:00:00");
	});

	// Handle invalid Date objects
	it("should throw an error when date object is invalid", () => {
		const invalidDate = new Date("invalid");
		expect(() => dateToSQLDatetimeString(invalidDate)).toThrow();
	});

	// Handle dates at Unix epoch start (1970-01-01)
	it("should format Unix epoch start date to SQL datetime string", () => {
		const testDate = new Date(1970, 0, 1, 0, 0, 0);
		const result = dateToSQLDatetimeString(testDate);
		expect(result).toBe("1970-01-01 00:00:00");
	});
});
